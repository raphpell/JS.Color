<!DOCTYPE HTML>
<html>
<head>
	<title>FX.js</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" href="css/page.css">
	<link rel="stylesheet" type="text/css" href="css/doc.css">
	<link rel="stylesheet" type="text/css" href="css/unittest.css">
	<style>
		#eForm {
			list-style-type: none;
			margin: 1em;
			padding: 0;
			position: relative;
			
			}
		#eForm li {
			clear: left;
			float: left;
			margin-bottom: 0.5em;
			z-index: 1000;
			}

		.square {
			border-radius: 100%;
			font: bold 16px verdana;
			font-size: 50px;
			filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity:0.5; opacity:0.5; 
			cursor: default;
			height: 50px;
			line-height: 50px;
			left: -10em;
			overflow: hidden;
			position: absolute;
			text-align: center;
			top: -10em;
			width: 50px;
			z-index: 1;
			display: flex;
			justify-content: center;
			align-items: center;
			}
		.red { background-color: rgba(255,0,0,1);}
		.green { background-color: rgba(0,255,0,1); }
		.blue { background-color: rgba(0,0,255,1); }

		#eReduce , #eExpand {
			cursor: pointer; cursor: hand;
			}
		#eFrames A, #eFrames A:visited {
			background: #FFF;
			border-right: 2px solid #000;
			color: #000;
			float: left;
			height: 2em;
			line-height: 2em;
			padding: 0 2px;
			text-decoration: none;
			}
		#eFrames A:hover {
			background: #000;
			color: #FFF;
			}
		#eFrames A.active {
			background: blue;
			color: yellow;
			}

		#eEffectTest {
			background: #666;
			clear: both;
			margin: 1em;
			text-align: center;
			width: 600px;
			}
		#eEffectTestP {
			background: #000;
			border: 0px solid #FC0;
			border-color: #FC0;
			color: #FFF;
			filter:alpha(opacity=50);-moz-opacity:0.5;-khtml-opacity:0.5;opacity:0.5;
			width: 200px;
			margin: 0 auto;
			}
	</style>
</head>
<body>

<ul class="pageMenu">
	<li><a href="index.htm">JS.Objects</a></li>
	<li onclick="goTo( eDoc )" id="eDocMenu">Documentation</li>
	<li onclick="goTo( eUnitTest )" id="eUnitTestMenu">Testes unitaires</li>
	<li onclick="goTo( eBenchmarking )" id="eBenchmarkingMenu">Benchmarking</li>
	<li onclick="goTo( ePlayground )" id="ePlaygroundMenu">Playground</li>
</ul>

<page id="ePreload" class="active">
	chargement...
</page>

<page id="eDoc">
	<h1>Objet FX</h1>
	<div id="eSummary1"></div>

	<div class="doc">
		<section>
			<code>/*  REQUIS Les classes Color et Style... */</code>
			<p>
				Cet objet permet de créer des animations complexes d'un élément html.<br>
				Ces animations peuvent être concaténer, fusionner ou 'pousser à la suite'...ou_ altérer. 
			</p>
			<p>
				Les attributs gérés sont ceux avec une valeur en pixel ou une couleur rgb,rgba,... (pas de nom de couleur).
			</p>
			<p>Syntaxe: <code>var oFx = new Fx ( eHtmlElement [, o2 [, mEffect [, nTime [, oSettings ]]]])</code></p>
			<dl>
				<dt><var>e</var> : <i>HTMLElement</i></dt>
				<dd>Element html.</dd>
				<dt><var>o2</var> : <i>Object</i>, <i><small>Optionnel.</small></i> </dt>
				<dd>Styles css à atteindre. Par extension les propriétés <code>scroll</code> sont prises en charge. Exemples :
					<ul>
						<li><code>{ 'padding-left':12, color:'#FC0' }</code></li>
						<li><code>{ scrollLeft:600, scrollTop:600 }</code></li>
					</ul>
				</dd>
				<dt><var>mEffect</var> : <i>mixte</i>, <i><small>Optionnel.</small></i> <small>Valeur par défaut : </small><b><code>Fx.effect</code></b></dt>
				<dd>
					Effet utilisé. Fonction, chaîne ou tableau. Valeurs chaînes prédisponibles :
					<i>linear | (( quad | quint| sine | expo | circ | elastic | back | bounce ).( in | out | inOut ))</i>
					<p>Exemples :</p>
					<ul>
						<li><code>'linear'</code></li>
						<li><code>'circ.inOut'</code></li>
					</ul>
					<p>Les fonctions créées doivent respecter les conditions citées dans <a href="#_Fx.Effects">Fx.Effects</a>.</p>
					<p>Si cet argument est un tableau il doit contenir :</p>
					<ul>
						<li>Une fonction ou une chaîne contenant l'effet utilisé (cf. ci-dessus)</li>
						<li>Le temps de l'effet. Cette valeur sera privilégiée à l'argument <var>nTime</var> (cf. ci-dessous).</li>
					</ul>
				</dd>
				<dt> <var>nTime</var> : <i>Number</i>, <i><small>Optionnel.</small></i><small>Valeur par défaut : </small><code>Fx.time</code></dt>
				<dd>Temps de l'effet en millisecondes.</dd>
				<dt> <var>oSettings</var> : <i>Object</i>, <i><small>Optionnel.</small></i> <small>Valeur par défaut : </small><code>Fx.oDefaultSettings</code></dt>
				<dd>Paramètres supplémentaires de l'effet (Cf. <a href="#_oDefaultSettings">Fx.oDefaultSettings</a>)</dd>
			</dl>
		</section>
		<section><h2>Instances</h2>
			<section><h3> playFrame (<var> nId, [ bJustOne=false ]</var>)</h3>
				<p>Joue une image de l'animation...</p>
				<dl>
					<dt><var>nId</var> <i>Number</i> - Numéro de l'image.</dt>
					<dt><var>bJustOne</var> <i>Boolean</i> - A <code>false</code> l'animation est joué.</dt>
				</dl>
			</section>
			<section><h3> back (<var> [ sEffect=this.fFx, [ nTime=this.time ]] </var>)</h3>
				<p>Ajoute une animation faisant retourner l'élément à son dernier état initial.</p>
				<p>Préférer la méthode <code>reverse()</code> pour revenir en arrière avec l'effet précédemment utilisé.</p>
				<dl>
					<dt><var>sEffect</var> <i>String</i> - Effet de retour.</dt>
					<dt><var>nTime</var> <i>Number</i> - Temps de l'animation.</dt>
				</dl>
				<p>Retourne un objet Fx.</p>
			</section>
			<section><h3> blink (<var> n </var>)</h3>
				<p>Joue l'animation d'avant en arrière n fois.</p>
				<p>Utiliser la méthode <code>reverse()</code> pour n=1.</p>
				<dl>
					<dt><var>n</var> <i>Number</i> - Nombre de fois où l'élément 'clignote'.</dt>
				</dl>
			</section>
			<section><h3> concat (<var> o2, [ sEffect=this.fFx, [ nTime=this.time ]] </var>)</h3>
				<p>Ajoute une animation à la suite.</p>
				<dl>
					<dt><var>o2</var> <i>Object</i> - Style à atteindre.</dt>
					<dt><var>sEffect</var> <i>String</i> - Effet.</dt>
					<dt><var>nTime</var> <i>Number</i> - Temps.</dt>
				</dl>
				<p>Retourne l'animation Fx créée.</p>
			</section>
			<section><h3> custom (<var> oFrames, oSettings </var>)</h3>
				<p>Ajoute à la suite une animation personnalisée.</p>
				<dl>
					<dt><var>oFrames</var> <i>Object</i> - Objet contenant pour chaque attribut modifié de l'élément un tableau des valeurs.</dt>
					<dt><var>oSettings</var> <i>Object</i> - Configuration de l'animation.</dt>
				</dl>
				<p>Retourne l'animation Fx créée.</p>
			</section>
			<section><h3> merge (<var> o2, [ sEffect=this.fFx, [ nTime=this.time, [ bPreserve=false ]]] </var>)</h3>
				<p>Fusionne une animation avec de nouveaux états finaux.</p>
				<dl>
					<dt><var>o2</var> <i>Object</i> - Style à atteindre.</dt>
					<dt><var>sEffect</var> <i>String</i> - Effet.</dt>
					<dt><var>nTime</var> <i>Number</i> - Temps.</dt>
					<dt><var>bPreserve</var> <i>Booléen</i> - A <code>true</code> préserve les attributs déjà altérés de l'élément et ignore les nouvelles valeurs.</dt>
				</dl>
				<p>Retourne cet objet. </p>
			</section>
			<section><h3> push (<var> o2, [ sEffect=this.fFx, [ nTime=this.time, [ oSettings ]]] </var>)</h3>
				<p>Pousse des 'animations' dans l'animation courante.</p>
				<p>Aucun nouvel objet Fx est crée: le temps de l'animation est altéré pour les attributs modifiés déjà présent dans l'animation.</p>
				<dl>
					<dt><var>o2</var> <i>Object</i> - Style à atteindre.</dt>
					<dt><var>sEffect</var> <i>String</i> - Effet.</dt>
					<dt><var>nTime</var> <i>Number</i> - Temps.</dt>
					<dt><var>oSettings</var> <i>Object</i> - Configuration de l'animation.</dt>
				</dl>
				<p>Retourne cet objet.</p>
			</section>
			<section><h3> repeat (<var> n </var>)</h3>
				<p>Répète une animation. Si aucun nombre de répétition est défini, l'animation se répète à l'infini.</p>
				<dl>
					<dt><var>n</var> <i>Number</i> - Nombre de fois où l'animation est répétée.</dt>
				</dl>
			</section>
			<section><h3> reverse (<var></var>)</h3>
				<p>Joue l'animation en arrière, une fois jouée.</p>
			</section>
		</section>
		<section><h2>Evénements</h2>
			<section><h3>Evénements utilisateurs</h3>
				<p>Ces événements peuvent être définis.</p>
				<section><h4>oncomplete</h4>
					<p>Evénement déclenché à la fin de l'animation.</p>
					<p>Si elle retourne :</p>
					<dl>
						<dt><var>true</var>: - La suite d'animation continue d'être joué.</dt>
						<dt><var>false</var>: - La suite d'animation est stoppée.</dt>
					</dl>
					<p>Rappel: des animations peuvent être ajouté à la suite.</p>
				</section>
				<section><h4>onframe( nId, bJustOne )</h4>
					<p>Evénement déclenché lorsqu'une image est jouée.</p>
					<dl>
						<dt><var>nId</var> <i>Number</i> - Numéro de l'image.</dt>
						<dt><var>bJustOne</var> <i>Boolean</i> - Indique si seule l'image est jouée.</dt>
					</dl>
				</section>
				<section><h4>onlaunch</h4>
					<p>Evénement déclenché au début de l'animation.</p>
				</section>
			</section>
			<section style="background:#eee;"><h3>Evénements privés</h3>
				<p>Ils sont déclenchés à la fin d'une suite d'animations.</p>
				<p>Ces événements 'privés' sont utilisés par les méthodes <var>blink, repeat, reverse</var>.</p>
				<section><h4>onend</h4>
					<p>Evénement déclenché à la fin d'une suite d'animations <b>jouée à l'endroit</b>.</p>
				</section>
				<section><h4>onstart</h4>
					<p>Evénement déclenché à la fin d'une suite d'animations <b>jouée à l'envers</b>.</p>
				</section>
			</section>
		</section>
		<section><h2>Fx</h2>
			<section><h3>oDefaultSettings : Object</h3>
				<p>Paramètres par défaut des animations.</p>
				<dl>
					<dt><code>bColorRGBA : true</code> - Stockage des couleurs en rgba ou hexadécimal (sans opacité) à false.</dt>
					<dt><code>bPlayNow : true</code> - Animation jouée immédiatement une fois créée.</dt>
					<dt><code>bPreserveMergin : true</code> - Si la méthode d'ajout est 'merge', protection des attributs de l'effet déjà existant.</dt>
					<dt><code>bAnimationFrame : true</code> - Utilisation du système d'animation natif javascript.</dt>
					<dt><code>fps : 60</code> - Si bAnimationFrame est égale à false, nombre d'images par seconde.</dt>
					<dt><code>method : 'concat'</code> - Choix possibles: concat || merge || push.</dt>
					<dt><code>sColorMode : 'rgb'</code> - Choix possibles: rgb || hsv || hsl || rgba || hsva || hsla || cmyk.</dt>
					<dt><code>time : 500</code>- Temps des animations par défaut.</dt>
					<dt><code>oncomplete : ()=>true</code>- Méthode lancé à la fin d'une animation. Si elle retourne false, la suite d'animations est stoppée.</dt>
					<dt><code>onframe : nId=>{}</code>- Méthode lancé à chaque image d'une animation.</dt>
					<dt><code>onlaunch : ()=>{}</code>- Méthode lancé au lancement d'une animation.</dt>
				</dl>
			</section>
			<section style="background:#eee;"><h3>animation (<var> oFx </var>)</h3>
				<p>Ajoute une animation à jouer... cette fonction privée est visible pour le benchmarking.</p>
				<dl>
					<dt><var>oFx</var> : <i>Fx</i>. Instance de Fx.</dt>
				</dl>
				<section>
					<p>L'objet gèrant l'animation est privé.</p>
					<p>
						Par défaut, les objets Fx ont l'attribut <var>bAnimationFrame</var> = true et l'animation est gérer par la méthode native <var>requestAnimationFrame</var>.
					</p>
					<p>
						Il est possible, en passant <var>bAnimationFrame</var> à false, de définir le nombre d'images par seconde pour chaque animation.<br>
						Celà dit, les résultats sont instables selon le navigateur utilisé.
					</p>
				</section>
			</section>
			<section><h3>custom (<var> e,oFrames,oSettings </var>)</h3>
				<p>Ajoute à la suite d'animations de l'élément e, une animation personnalisée.</p>
				<dl>
					<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
					<dt><var>oFrames</var> <i>Object</i> - Objet contenant pour chaque attribut modifié de l'élément un tableau des valeurs.</dt>
					<dt><var>oSettings</var> <i>Object</i> - Configuration de l'animation.</dt>
				</dl>
				<p>Retourne l'animation Fx créée.</p>
			</section>
			<section><h3>getEffect (<var> m </var>)</h3>
				<p>Cherche la fonction dans Fx.Effects à utiliser pour calculer une transition d'un effet. </p>
				<dl><dt><var>m</var> : <i>String ou Function</i> Nom d'un effet (exemples: "linear" ou "expo.out"), ou une fonction répondant au critère des effets.</dt></dl>
				<p>Par défaut elle retourne la fonction <var>Fx.Effects.linear</var>. </p>
			</section>
			<section><h3>pause (<var> e </var>)</h3>
				<p>Pause la suite d'animations d'un élment HTML.</p>
				<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
			</section>
			<section><h3>playing (<var> e </var>)</h3>
				<p>Indique si l'animation d'un élément est jouée ou est en pause.</p>
				<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
			</section>
			<section><h3>play (<var> e </var>)</h3>
				<p>Joue la suite d'animations d'un élément depuis son début...</p>
				<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
			</section>
			<section><h3>playInvert (<var> e </var>)</h3>
				<p>Joue la suite d'animations d'un élément depuis sa fin...</p>
				<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
			</section>
			<section><h3>stop (<var> e </var>)</h3>
				<p>Stoppe l'animation d'un élément.</p>
				<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
				<p>L'animation est détruite mais récupérable avec l'événement e.onstop( oFx ).</p>
			</section>
			<section style="background:#eee;"><h3>createFrames (<var> oFx </var>)</h3>
				<p>Créé les images de l'animation... cette fonction privée est visible pour le benchmarking.</p>
			</section>
			<section style="background:#eee;"><h3>calculateDeltas (<var> oFx </var>)</h3>
				<p>Calcul la différence entre l'état final et l'état initial... cette fonction privée est visible pour le benchmarking.</p>
			</section>
			<section><h3>Last (<var> e </var>)</h3>
				<p>Retourne la dernière animation de l'élément e.</p>
				<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
				<section><h4>get_o1 (<var> e </var>)</h4>
					<p>Calcul l'état initial de la dernière animation.</p>
					<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
				</section>
				<section><h4>get_o2 (<var> e </var>)</h4>
					<p>Calcul l'état final de la dernière animation.</p>
					<dl><dt><var>e</var> : <i>HTMLElement</i></dt></dl>
				</section>
			</section>
			<section><h3>.Methods</h3>
				<section><h4>concat (<var> oFx </var>)</h4>
					<p>Ajoute l'animation à la suite d'animations de l'élément <var>oFx.e</var>.</p>
				</section>
				<section><h4>merge (<var> oFx, bPreserve </var>)</h4>
					<p>Fusionne l'animation à la dernière animation de la suite de'animations de l'élément <var>oFx.e</var>.</p>
				</section>
				<section><h4>push (<var> oFx </var>)</h4>
					<p>Pousse les images de l'animation derrière la dernière animation de la suite d'animations de l'élément <var>oFx.e</var>.</p>
				</section>
			</section>
			<section><h3>Effects</h3>
				<p>Objet contenant les fonctions calculant transitions. 
				Elles ont toutes quatre arguments:</p>
				<div class="arguments">
					<dl>
						<dt><var>t</var> : <i>Number</i>. Temps en milliseconde (doit commencer par zéro).</dt>
						<dt><var>b</var> : <i>Number</i>. Valeur au départ.</dt>
						<dt><var>c</var> : <i>Number</i>. Différence entre la valeur finale et la valeur au départ.</dt>
						<dt><var>d</var> : <i>Number</i>. Durée en milliseconde.</dt>
					</dl>
				</div>
				<p>La valeur retourné par ces fonctions quand b=0, c=1 et d=1, est:</p>
				<ul>
					<li>si t=0, 0.</li><li>si t=1, 1.</li>
				</ul>
				<p>Il est possible d'en rajouter. Liste des effets disponibles.</p>
				<ul>
					<li>linear: seul effet sans choix <var>in, out, inOut</var>.</li>
					<li>quad</li>
					<li>quint</li>
					<li>sine</li>
					<li>expo</li>
					<li>circ</li>
					<li>elastic</li>
					<li>back</li>
					<li>bounce</li>
				</ul>
			</section>
		</section>
	</div>
</page>
<page id="eUnitTest">
	<h1>Testes unitaires</h1>
	<div id="eSummary2"></div>
</page>
<page id="eBenchmarking">
	<h1>Benchmarking</h1>
	<div id="eSummary3"></div>
	<span id="eTest" style="background-color: #eee; padding: 5px;">#eTest</span>
	<span id="eTest2" style="background-color: #eee; padding: 5px;">#eTest2</span>
</page>
<page id="ePlayground">
	<h1>Playground</h1>
	<div style="float:right;">
		<p>Touches raccourcies : </p>
		<ul>
			<li> <kbd>ESC</kbd> : Stoppe l'animation
			<li> <kbd>SPACE</kbd> : Lance et pause l'animation
		</ul>
		<div id="e1" class="square red">1</div>
		<div id="e2" class="square green">2</div>
		<div id="e3" class="square blue">3</div>
	</div>
	<ul id="eForm">
		<li>
			<label for="eElement">Element : </label>
			<select id="eElement">
				<option value="e1">1</option>
				<option value="e2">2</option>
				<option value="e3" select>3</option>
			</select>
			Cliquer pour déplacement l'élément
		<li><label for="eType">Effet : </label>
			<select id="eTransition">
				<option value="linear">linear</option>
				<option value="quad">quad</option>
				<option value="quint">quint</option>
				<option value="sine">sine</option>
				<option value="expo">expo</option>
				<option value="circ">circ</option>
				<option value="elastic">elastic</option>
				<option value="back">back</option>
				<option value="bounce" selected>bounce</option>
				<option value="bidon">bidon</option>
			</select>
			<select id="eType">
				<option value="in">in</option>
				<option value="out" selected>out</option>
				<option value="inOut">inOut</option>
				<option value="off">off</option>
			</select>
		<li>
			<label for="eType">Mode couleur : </label>
			<select id="eColorMode">
				<option value="rgb">rgb</option>
				<option value="rgba"selected>rgba</option>
				<option value="hsv">hsv</option>
				<option value="hsva">hsva</option>
				<option value="hsl">hsl</option>
				<option value="hsla">hsla</option>
				<option value="cmyk">cmyk</option>
			</select>
			<label for="eColor1">Couleur 1 : </label><input id="eColor1" type="color" value="#FF0000">
			<label for="eColor2">Couleur 2 : </label><input id="eColor2" type="color" value="#00FFFF">
			<div id="eEffectTest"><p id="eEffectTestP"> Survoler </p></div>
		<li>
			<label for="eTime">Temps : </label><input type="test" id="eTime">
			<label for="eFPS">Fps : </label><input type="test" id="eFPS">
			<input type="checkbox" id="eRequestAnimationFrame" checked><label for="eRequestAnimationFrame">Utiliser <code>requestAnimationFrame</code>.</label>
		<li>
		<li>
			<label for="eMethod">Méthode : </label>
			 <select id="eMethod">
				<option value="concat" select>concat</option>
				<option value="merge">merge</option>
				<option value="push">push</option>
			 </select>
			<input type="checkbox" id="ePreserveMergin" checked disabled><label for="ePreserveMergin">Préserver le dernier effet.</label>
		<li>
			<input type="checkbox" id="ePlay" checked><label for="ePlay">Jouer</label>
			<input type="checkbox" id="ePlayInvert"><label for="ePlayInvert">Jouer en arrière.</label>
			<input type="checkbox" id="eClear"><label for="eClear">Nettoyer avant</label>
		<li>
			font-size, width, height, opacity :
			<button id="eReduce">--</button>
			<button id="eExpand">++</button>
		<li>
			Opacité couleur : 
			<button id="eRGBAMinus">--</button>
			<button id="eRGBAPlus">++</button>
			( Mode couleur avec opacité nécessaire: rgba, hsva ou hsla )
		<li>
			<input type="checkbox" id="eBack"><label for="eBack">Retour calculer.</label>
			<ol>
				<li><input type="radio" name="suffix" id="eNull" checked><label for="eNull">rien.</label>
				<li><input type="radio" name="suffix" id="eReverse"><label for="eReverse">A la fin, jouer en arrière.</label>
				<li><input type="radio" name="suffix" id="eBlinked"><label for="eBlinked">Jouer en avant et en arrière : </label>
					<input id="eBlink" type="text" size="3">
				<li><input type="radio" name="suffix" id="eRepeated"><label for="eRepeated">Répéter : </label>
					<input id="eRepeat" type="text" size="3">
			</ol>
		<li>
			Images de l'animation : (Décocher la case Jouer) <button id="eBtnPlay">Jouer</button>
			<div id="eFrames" style="display: "></div>
	</ul>
</page>

<script src="src/Color.js"></script>
<script src="src/CssRules.js"></script>
<script src="src/Style.js"></script>
<script src="src/FX.js"></script>
<script src="src/Keyboard.js"></script>
<script src="src/Mouse.js"></script>
<script src="js/page.js"></script>
<script src="js/doc.js"></script>
<script src="js/unittest.js"></script>
<script src="js/benchmark.js"></script>
<script>
// DOCUMENTATION
layoutDoc( eSummary1, { numbers: false, links: true }, eDoc )

// TESTS UNITAIRES
new UnitTest( eUnitTest,[
	{ desc:"...." },
	{ title:"Instance FX",
		list:[
			{ title:"countFrames",
				desc:"L'unité temps est milliseconde mais bon... des secondes en choix.",
				eval:"window.oFx = new Fx ( {}, {}, 'linear', 1000, { fps: 50 })",
				assertions:[
					"oFx.countFrames() === 51",
					"oFx.time = 500",
					"oFx.countFrames() === 26",
					"oFx.fps = 40",
					"oFx.countFrames() === 21",
					]
				}
			]
		},
	{ title:"Objet FX",
		desc:'',
		list:[
			{ title:"calculateDeltas",
				eval:
`let e = { style:{}}
window.oFx0 = new Fx ( e, null, 'linear', 200, { bColorRGBA:false })
oFx0.o1 = { color:'#A0B0CA', margin:50 }
oFx0.o2 = { color:'#AABAC0', margin:150 }`,
				assertions:[
					"oFx0.o1 && oFx0.o2",
					"! oFx0.aAttr",
					"! oFx0.oDeltas.get('color')",
					"! oFx0.oDeltas.get('margin')",
					"Fx.calculateDeltas && ! Fx.calculateDeltas( oFx0 )",
					`JSON.stringify( oFx0.oDeltas.get('color') ) === '{"r":10,"g":10,"b":-10,"sType":"Color"}'`,
					"oFx0.oDeltas.get('margin') === 100",
					"[...oFx0.aAttr].toString() === 'color,margin'",
					"! oFx0.oFrames.get('color')",
					"! oFx0.oFrames.get('margin')",
					"Fx.createFrames && ! Fx.createFrames( oFx0 )",
					"oFx0.fps == 60",
					"oFx0.time!=200 && oFx0.time==192",
					"oFx0.oFrames.get('color')[0]===oFx0.o1.color.toHEX().toString('#')",
					"oFx0.oFrames.get('color')[oFx0.nFrames-1]===oFx0.o2.color.toHEX().toString('#')",
					"oFx0.oFrames.get('color').length === oFx0.nFrames",
					"oFx0.oFrames.get('color').join( ',' ) === '#A0B0CA,#A0B0C9,#A1B1C8,#A2B2C7,#A3B3C6,#A4B4C5,#A5B5C5,#A5B5C4,#A6B6C3,#A7B7C2,#A8B8C1,#A9B9C0,#AABAC0'",
					"oFx0.oFrames.get('margin').length === oFx0.nFrames",
					"oFx0.oFrames.get('margin').join( ',' ) === '50,58,66,75,83,91,100,108,116,125,133,141,150'"
					]
				},
			{ title:".Methods",
				eval:
`window.sL2 = '0,2,6,10'
window.sP2 = '10,12,16,20'
window.sP3 = '20,17,15'
window.sW3 = '100,150,200'

window.fArray = s=> s.split( ',' )
window.fLength = s=> s.split( ',' ).length
window.fFirst = s=> parseInt( fArray( s ).shift())
window.fLast = s=> parseInt( fArray( s ).pop())

window.ePseudoHtmlElement = {}
window.getFX = function( n ){
	switch( n ){
		case 1: return {
			e : ePseudoHtmlElement,
			aAttr: new Set,
			nFrames: 0,
			oFrames: new Map,
			o1: {},
			o2: {}
			}
		case 2: return {
			e : ePseudoHtmlElement,
			aAttr: new Set(['left','padding']),
			nFrames: fLength(sL2),
			oFrames: new Map ([ ['left',fArray(sL2)], ['padding',fArray(sP2)] ]),
			o1: { left:fFirst(sL2), padding:fFirst(sP2)},
			o2: { left:fLast(sL2), padding:fLast(sP2)}
			}
		case 3: return {
			e : ePseudoHtmlElement,
			aAttr: new Set(['padding','width']),
			nFrames: fLength(sP3),
			oFrames: new Map ([ ['padding',fArray(sP3)], ['width',fArray(sW3)] ]),
			o1: { padding:fFirst(sP3), width:fFirst(sW3)},
			o2: { padding:fLast(sP3), width:fLast(sW3)}
			}
		}
	}`,
				list:[
					{ title:".merge",
						list:[
							{ desc:"Ajout simple",
								eval:
`window.oFx1 = getFX(1)
window.oFx2 = getFX(2)
window.oFx3 = getFX(3)
ePseudoHtmlElement.oFx = null`,
								assertions:[
									'oFx1 === Fx.Methods.merge( oFx1 )',
									'oFx1 === Fx.Methods.merge( oFx2 )',
									'oFx1 === Fx.Methods.merge( oFx3 )',
									'ePseudoHtmlElement.oFx === oFx1',
									'oFx1.nFrames === 4',
									'oFx1.o1.left === fFirst( sL2 )',
									'oFx1.o1.padding === fFirst( sP3 )',
									'oFx1.o1.width === fFirst( sW3 )',
									'oFx1.o2.left === fLast( sL2 )',
									'oFx1.o2.padding === fLast( sP3 )',
									'oFx1.o2.width === fLast( sW3 )',
									]},
							{ desc:"Préservation",
								eval:
`window.oFx1 = getFX(1)
window.oFx2 = getFX(2)
window.oFx3 = getFX(3)
ePseudoHtmlElement.oFx = oFx1
oFx1.next = oFx2`,
								assertions:[
									'oFx1 === Fx.Methods.merge( oFx3, true )',
									'ePseudoHtmlElement.oFx = oFx1',
									'[...oFx2.aAttr].toString() === "left,padding,width"',
									'oFx2.nFrames === 4',
									'oFx2.oFrames.get("left").toString() === sL2',
									'oFx2.oFrames.get("padding").toString() === sP2',
									'oFx2.oFrames.get("width").toString() === sW3',
									'oFx2.o1.left === fFirst( sL2 )',
									'oFx2.o1.padding === fFirst( sP2 )',
									'oFx2.o1.width === fFirst( sW3 )',
									'oFx2.o2.left === fLast( sL2 )',
									'oFx2.o2.padding === fLast( sP2 )',
									'oFx2.o2.width === fLast( sW3 )'
									]},
							{ desc:"Remplacement",
								eval:
`window.oFx1 = getFX(1)
window.oFx2 = getFX(2)
window.oFx3 = getFX(3)
ePseudoHtmlElement.oFx = oFx1
oFx1.next = oFx2`,
								assertions:[
									'oFx1 === Fx.Methods.merge( oFx3 )',
									'ePseudoHtmlElement.oFx = oFx1',
									'[...oFx2.aAttr].toString() === "left,padding,width"',
									'oFx2.nFrames === 4',
									'oFx2.oFrames.get("left").toString() === sL2',
									'oFx2.oFrames.get("padding").toString() === sP3',
									'oFx2.oFrames.get("width").toString() === sW3',
									'oFx2.o1.left === fFirst( sL2 )',
									'oFx2.o1.padding === fFirst( sP3 )',
									'oFx2.o1.width === fFirst( sW3 )',
									'oFx2.o2.left === fLast( sL2 )',
									'oFx2.o2.padding === fLast( sP3 )',
									'oFx2.o2.width === fLast( sW3 )'
									]},
							{
								eval:
`window.oFx1 = getFX(1)
window.oFx2 = getFX(2)
window.oFx3 = getFX(3)
ePseudoHtmlElement.oFx = oFx1
oFx1.next = oFx3`,
								assertions:[
									'oFx1 === Fx.Methods.merge( oFx2 )',
									'ePseudoHtmlElement.oFx = oFx1',
									'[...oFx3.aAttr].toString() === "padding,width,left"',
									'oFx3.nFrames === 4',
									'oFx3.oFrames.get("left").toString() === sL2',
									'oFx3.oFrames.get("padding").toString() === sP2',
									'oFx3.oFrames.get("width").toString() === sW3',
									'oFx3.o1.left === fFirst( sL2 )',
									'oFx3.o1.padding === fFirst( sP2 )',
									'oFx3.o1.width === fFirst( sW3 )',
									'oFx3.o2.left === fLast( sL2 )',
									'oFx3.o2.padding === fLast( sP2 )',
									'oFx3.o2.width === fLast( sW3 )'
									]}
							]
						},
					{ title:".concat",
						eval:
`window.oFx1 = getFX(1)
window.oFx2 = getFX(2)
window.oFx3 = getFX(3)
ePseudoHtmlElement.oFx = null`,
						assertions:[
							'oFx1 === Fx.Methods.concat( oFx1 )',
							'oFx1 === Fx.Methods.concat( oFx2 )',
							'oFx1.next === oFx2',
							'oFx2.previous === oFx1',
							'oFx1 === Fx.Methods.concat( oFx3 )',
							'oFx2.next === oFx3',
							'oFx3.previous === oFx2',
							'ePseudoHtmlElement.oFx === oFx1'
							],
						},
					{ title:".push",
						eval:
`window.oFx1 = getFX(1)
window.oFx2 = getFX(2)
window.oFx3 = getFX(3)
ePseudoHtmlElement.oFx = oFx1
oFx1.next = oFx2`,
						assertions:[
							'oFx1 === Fx.Methods.push( oFx3 )',
							'[...oFx2.aAttr].toString() === "left,padding,width"',
							'oFx2.nFrames === 7',
							'oFx2.oFrames.get("left").toString() === sL2',
							'oFx2.oFrames.get("padding").toString() === sP2+","+sP3',
							'oFx2.oFrames.get("width").toString() === sW3',
							'oFx2.o1.left === fFirst( sL2 )',
							'oFx2.o1.padding === fFirst( sP2 )',
							'oFx2.o1.width === fFirst( sW3 )',
							'oFx2.o2.left === fLast( sL2 )',
							'oFx2.o2.padding === fLast( sP3 )',
							'oFx2.o2.width === fLast( sW3 )',
							],
						},
					],
				},
			{ title:".Effects",
				list:[
					{ title:".linear",
						assertions:[
							"Fx.Effects.linear( 0, 0, 1, 1 )===0",
							"Fx.Effects.linear( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".quad",
						assertions:[
							"Fx.Effects.quad.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.quad.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.quad.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.quad.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.quad.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.quad.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".quint",
						assertions:[
							"Fx.Effects.quint.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.quint.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.quint.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.quint.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.quint.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.quint.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".sine",
						assertions:[
							"Fx.Effects.sine.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.sine.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.sine.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.sine.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.sine.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.sine.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".expo",
						assertions:[
							"Fx.Effects.expo.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.expo.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.expo.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.expo.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.expo.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.expo.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".circ",
						assertions:[
							"Fx.Effects.circ.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.circ.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.circ.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.circ.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.circ.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.circ.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".elastic",
						assertions:[
							"Fx.Effects.elastic.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.elastic.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.elastic.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.elastic.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.elastic.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.elastic.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".back",
						assertions:[
							"Fx.Effects.back.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.back.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.back.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.back.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.back.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.back.inOut( 1, 0, 1, 1 )===1",
							]
						},
					{ title:".bounce",
						assertions:[
							"Fx.Effects.bounce.in( 0, 0, 1, 1 )===0",
							"Fx.Effects.bounce.in( 1, 0, 1, 1 )===1",
							"Fx.Effects.bounce.out( 0, 0, 1, 1 )===0",
							"Fx.Effects.bounce.out( 1, 0, 1, 1 )===1",
							"Fx.Effects.bounce.inOut( 0, 0, 1, 1 )===0",
							"Fx.Effects.bounce.inOut( 1, 0, 1, 1 )===1",
							]
						},
					],
				},
			],
	}],
	{ unittest:1, benchmark: 0 }
	)

layoutDoc( eSummary2, { numbers: false, links: true }, eUnitTest )


// BENCHMARKING
new UnitTest( eBenchmarking ,[
	{ title:"Instance FX",
		list:[
			{ title:"new",
				desc:'Un peu lent au premier abord...',
				eval:'window.eTest = document.getElementById("eTest")',
				assertions:[
					'window.oFx11 = new Fx ( eTest, { "background-color":"#FC0", "padding":"50" }, "sin.out", 100 )',
					'oFx11.reverse()'
					]
				},
			{ title:"countFrames",
				assertions:[
					
					]
				}
			]
		},
	{ title:"Objet FX",
		desc:'',
		list:[
			{ title:"calculateDeltas / createFrames",
				eval:
`window.init = ()=>{
	let e = { style:{}}
	window.oFx = new Fx ( e, 0, 'linear', 200, 0, { bPlayNow: false })
	oFx.o1 = { color:'#A0B0CA', margin:50 }
	oFx.o2 = { color:'#AABAC0', margin:150 }
	}`,
				assertions:[
					'init(); oFx.bPlayNow === false',
					'init(); Fx.calculateDeltas( oFx )',
					'init(); Fx.createFrames( oFx )',
					'delete window.oFx'
					]
				},
			{ title:".Methods",
				list:[
					{ title:".merge",
						list:[
							{ desc:"Ajout simple",
								eval:
`window.reset1 = ()=>{
	window.oFx1 = getFX(1)
	window.oFx2 = getFX(2)
	window.oFx3 = getFX(3)
	ePseudoHtmlElement.oFx = null
	}`,
								assertions:[
									'reset1()',
									'reset1();Fx.Methods.merge( oFx1 );Fx.Methods.merge( oFx2 );Fx.Methods.merge( oFx3 )',
									]},
							{ desc:"Préservation",
								eval:
`window.reset2 = ()=>{
	window.oFx1 = getFX(1)
	window.oFx2 = getFX(2)
	window.oFx3 = getFX(3)
	ePseudoHtmlElement.oFx = oFx1
	oFx1.next = oFx2
	}`,
								assertions:[
									'reset2()',
									'reset2();Fx.Methods.merge( oFx3, true )'
									]},
							{ desc:"Remplacement",
								eval:
`window.reset3 = ()=>{
	window.oFx1 = getFX(1)
	window.oFx2 = getFX(2)
	window.oFx3 = getFX(3)
	ePseudoHtmlElement.oFx = oFx1
	oFx1.next = oFx2
	}`,
								assertions:[
									'reset3()',
									'reset3();Fx.Methods.merge( oFx3 )'
									]},
							{
								eval:
`window.reset4 = ()=>{
	window.oFx1 = getFX(1)
	window.oFx2 = getFX(2)
	window.oFx3 = getFX(3)
	ePseudoHtmlElement.oFx = oFx1
	oFx1.next = oFx3
	}`,
								assertions:[
									'reset4()',
									'reset4();Fx.Methods.merge( oFx2 )',
									]}
							]
						},
					{ title:".concat",
						eval:
`window.reset5 = ()=>{
	ePseudoHtmlElement.oFx = null
	window.oFx1 = getFX(1)
	window.oFx2 = getFX(2)
	window.oFx3 = getFX(3)
	}`,
						assertions:[
							'reset5()',
							'reset5();Fx.Methods.concat( window.oFx1 );Fx.Methods.concat( window.oFx2 );Fx.Methods.concat( oFx3 )'
							],
						},
					{ title:".push",
						eval:
`window.reset6 = ()=>{
	window.oFx1 = getFX(1)
	window.oFx2 = getFX(2)
	window.oFx3 = getFX(3)
	ePseudoHtmlElement.oFx = oFx1
	oFx1.next = oFx2
	}`,
						assertions:[
							'reset6()',
							'reset6();Fx.Methods.push( oFx3 )',
							],
						}
					],
				},
			{ title:".Effects",
				list:[
					{ title:"linear",
						assertions:[
							"Fx.Effects.linear( 1, 0, 1, 1 )",
							]
						},
					{ title:"quad",
						assertions:[
							"Fx.Effects.quad.in( 1, 0, 1, 1 )",
							"Fx.Effects.quad.out( 1, 0, 1, 1 )",
							"Fx.Effects.quad.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"quint",
						assertions:[
							"Fx.Effects.quint.in( 1, 0, 1, 1 )",
							"Fx.Effects.quint.out( 1, 0, 1, 1 )",
							"Fx.Effects.quint.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"sine",
						assertions:[
							"Fx.Effects.sine.in( 1, 0, 1, 1 )",
							"Fx.Effects.sine.out( 1, 0, 1, 1 )",
							"Fx.Effects.sine.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"expo",
						assertions:[
							"Fx.Effects.expo.in( 1, 0, 1, 1 )",
							"Fx.Effects.expo.out( 1, 0, 1, 1 )",
							"Fx.Effects.expo.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"circ",
						assertions:[
							"Fx.Effects.circ.in( 1, 0, 1, 1 )",
							"Fx.Effects.circ.out( 1, 0, 1, 1 )",
							"Fx.Effects.circ.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"elastic",
						assertions:[
							"Fx.Effects.elastic.in( 1, 0, 1, 1 )",
							"Fx.Effects.elastic.out( 1, 0, 1, 1 )",
							"Fx.Effects.elastic.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"back",
						assertions:[
							"Fx.Effects.back.in( 1, 0, 1, 1 )",
							"Fx.Effects.back.out( 1, 0, 1, 1 )",
							"Fx.Effects.back.inOut( 1, 0, 1, 1 )",
							]
						},
					{ title:"bounce",
						assertions:[
							"Fx.Effects.bounce.in( 1, 0, 1, 1 )",
							"Fx.Effects.bounce.out( 1, 0, 1, 1 )",
							"Fx.Effects.bounce.inOut( 1, 0, 1, 1 )",
							]
						},
					],
				},
			],
		}
	],
	{ unittest:0, benchmark: 1 }
	)

layoutDoc( eSummary3, { numbers: false, links: true }, eBenchmarking )


// PLAYGROUND
Events ={
	get:evt=>evt?evt:(window.event?window.event:null),
	element:m=>{
		if(!m)return null
		if(m.nodeName)return m
		if(m.type){
			m=Events.get(m)
			return m.target?(m.target.nodeType==3?m.target.parentNode:m.target):m.srcElement
			}
		return false
		},
	stop:evt=>{
		if(evt=Events.get(evt)){
			evt.cancelBubble=true
			if(evt.stopPropagation)evt.stopPropagation() 
			}
		return false
		}
	}

let eCircle = e1
Tests ={
	init :()=>{
		eNull.checked = true
		eTime.value = Fx.oDefaultSettings.time
		eBlink.value = ''
		eRepeat.value = ''
		eFPS.value = Fx.oDefaultSettings.fps
		eFPS.disabled = true
		eRequestAnimationFrame.checked = true
		ePreserveMergin.disabled = true
		ePreserveMergin.checked = true
		ePlay.checked = true
		ePlayInvert.checked = false
		eClear.checked = false
		eBack.checked = false
		eColorMode.value = 'hsva'
		},

	// FX
	getEffect:()=> eTransition.value + ( eType.value ? '.' + eType.value : '' ),
	action:sAction=>{
		switch( sAction ){
			case 'move':
				let TagsSet = new Set (['INPUT','SELECT','LABEL','OPTION','BUTTON','A'])
				return evt =>{
					var e = Events.element(evt)
					if( ! TagsSet.has( e.nodeName )) Tests.defineFx( Mouse.position(evt), evt )
					}
			case 'expand':
			case 'reduce':
				return evt =>{
					eCircle = document.getElementById( eElement.value )
					eCircle.n = eCircle.n || parseInt( Style.get( eCircle, 'font-size' ))
					let n = sAction=='expand' ? eCircle.n+25 : eCircle.n-25
					eCircle.n = n
					Tests.defineFx( { opacity: n/500, 'font-size': n, height: n, width: n }, evt )
					}
			case 'rgbaPlus':
			case 'rgbaMinus':
				return evt =>{
					eCircle = document.getElementById( eElement.value )
					let o = Color( Style.get( eCircle, 'background-color' ))
					o.a = ! o.a && o.a!==0 ? 1 : o.a
					o.mode = 'rgba'
					o.a = sAction=='rgbaPlus'
						? (o.a<0.8?o.a+0.2:1)
						: (o.a>0.2?o.a-0.2:0)
					Tests.defineFx( { 'background-color': o.toString() }, evt )
					}
			}
		},
	defineFx:( o2, evt )=>{
		eCircle = document.getElementById( eElement.value )
		if( eClear.checked ) Fx.stop( eCircle )
		var b = eCircle.oFx
		var oFx = new Fx ( eCircle, o2, Tests.getEffect(), eTime.value, {
			bPlayNow: false,
			method: eMethod.value,
			sColorMode: eColorMode.value,
			bPreserveMergin: ePreserveMergin.checked,
			bAnimationFrame: eRequestAnimationFrame.checked,
			fps: eFPS.value
			})
	//	console.info( oFx )
		if( eBack.checked ) oFx = oFx.back()
		if( eReverse.checked ) oFx.reverse()
		if( eBlinked.checked ) oFx.blink( eBlink.value || undefined )
		if( eRepeated.checked ) oFx.repeat( eRepeat.value || undefined )
		if( ! Fx.playing( eCircle )) Tests[ ePlay.checked ? 'play' : 'addFrames' ]()
		return Events.stop( evt )
		},
	play:()=>{
		eFrames.innerHTML = ''
		Fx[ ePlayInvert.checked ? 'playInvert' : 'play' ]( eCircle )
		},

	// KEYBOARD
	keyHandler : evt =>{
		var n = Keyboard.code( evt )
		switch( n ){
			case 27:
				eFrames.innerHTML = ''
				Fx.stop( eCircle )
				return Events.stop( evt )
			case 32:
				Fx.playing( eCircle )
					? Fx.pause( eCircle )
					: Tests.play()
			}
		},

	// FRAMES
	eCurrentFrame:null,
	addFrames:()=>{
		eFrames.innerHTML = ''
		for( var nFrames=0, oFx=eCircle.oFx; oFx; oFx=oFx.next )
			nFrames += oFx.nFrames
		for( var i=0, eA; i<nFrames; i++ ){
			eA = document.createElement('A')
			eA.innerHTML = i+1
			eA.href = '#'
			eFrames.appendChild( eA )
			eA.onmousedown = eA.onfocus = Tests.changeFrame
			}
		},
	changeFrame:evt=>{
		var e = Events.element(evt)
		if( e.nodeName == 'A' && eCircle.oFx ){
			if( Tests.eCurrentFrame ) Tests.eCurrentFrame.className = ''
			Tests.eCurrentFrame = e
			e.className = 'active'
			eCircle.oFx.playFrame( e.innerHTML-1, true )
			}
		}
	}

for(var i=1;i<4;i++ ) ePlayground.appendChild( document.getElementById('e'+i))

eEffectTest.fx = n =>{
	new Fx ( eEffectTest.firstChild, {
		'opacity': n == 0 ? 0.5 : 1,
		'border-color': n == 0 ? eColor1.value : eColor2.value,
		'border-left-width': n,
		'border-right-width': n
		}, Tests.getEffect(), eTime.value, { sColorMode: eColorMode.value })
	}

Tests.init()


document.onkeydown = Tests.keyHandler
ePlayground.onmousedown = Tests.action('move')
eExpand.onclick = Tests.action( 'expand' )
eReduce.onclick = Tests.action( 'reduce' )
eRGBAMinus.onclick = Tests.action( 'rgbaMinus' )
eRGBAPlus.onclick = Tests.action( 'rgbaPlus' )
eMethod.onchange = eMethod.onkeyup = ()=>{ ePreserveMergin.disabled = eMethod.value=='concat' }
eRequestAnimationFrame.onchange = ()=>{
	if( eFPS.disabled = eRequestAnimationFrame.checked )
		eFPS.value = Fx.oDefaultSettings.fps
	}
eEffectTest.onmouseover = ()=> eEffectTest.fx(200)
eEffectTest.onmouseout = ()=> eEffectTest.fx(0)
eBtnPlay.onclick = Tests.play

/*
Une fois le code charger, afficher de la page d'accueil !!
... sans setTimeout SVP !
*/
setTimeout( ()=>goTo(), 10 )
</script>

</body>
</html>